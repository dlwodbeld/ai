"""
# 단순 삽입법

# 삽입하려는 데이터를 변수를 따로 하나 준비하여 대입한다. 
# 변수의 데이터를 이미 정렬된 데이터와 순서대로 비교한다. 
# 변수의 데이터보다 작은 데이터가 발견되면 그 뒤의 요소에 변수의 데이터를 삽입한다. 


# 올바른 순서가 되도록 하나씩 데이터를 삽입한다. 
# 단순 삽입법은 삽입 정렬, 기본 삽입법, 삽입법이라고 한다. 

0 1 2 3 4 
5 3 4 1 2


일단 index 0 을 정렬된 공이라고 가정한다. 


5        3 4 1 2
--   정렬된 공으로 가정

정렬이 안된 공들 중 첫번째 즉3을 정렬된 공들 중 올바른 순서가 되도록 삽입한다. 

3 5      4 1 2

0번째 칸의 앞에는 없기 때문에 5를 하나뒤로 이동하고 3인공을 0번째 칸에 넣는다. 
이제 3과 5 는 정렬된 상태가 되었다. 


다시 정렬이 안된 공들 중 첫번째 즉 4를 정렬된 공들 중 올바른 순서가 되도록 삽입한다. 

이 시점에서 '정렬된 공'은 0번칸의 3과 1번칸의 5 사이가 되므로 3의 뒤, 5의 앞이다. 
4를 5 앞에 삽입한다. 

3  4  5       1 2


다시 정렬이 안된 공들 중 첫번째 즉 1를 정렬된 공들 중 올바른 순서가 되도록 삽입한다. 

정렬된 공은 0번 칸의 3 1번칸의 4 2번칸의 5이다. 여기서 올바른 위치는 3의 앞이므로 
1을 3의 앞에 삽입한다. 

1  3  4  5      2
-----------
마지막으로 2를 정렬된 공들 중 올바른 순서가 되도록 삽입한다. 

1  2  3  4  5
"""

"""
# 퀵 정렬 quick sort

데이터를 대소 그룹의 둘로 나누어 분해하여 전체를 정렬하는 방식의 알고리즘
실행 속도가 빠른 것이 특징이다. 

대량의 데이터를 정렬할 때 자주 사용되며 유명한 정렬 알고리즘 중에서도 실제로 사용되는
빈도가 높은 가장 중요한 알고리즘의 하나이다. 


5 4 7 6 8 3 1 2 9

우선 정렬의 기준이 되는 공을 선택하자. 첫번재 기준은 5번 공이다.
기준 공 5보다 작은 공은5의 앞으로 이동시키고
기준 공 5보다 큰 공은 5의 뒤로 이동시킨다.

4   3   1   2   5   7   6   8   9
                -                   5는 정렬된상태
3정렬

1   2   3   4   5   6   7   8   9
        -       -       -           3,5,7는 정렬된상태
1   2   3   4   5   6   7   8   9
-   -   -   -   -   -   -   -   -   전부 정렬된상태.


#에라토스테네스의 체
# 소수를 찾아내는 알고리즘
소수는 2개이상의 정수중 1과 그 수 자신으로만 나눌 수 있는 수
소수는 나열되어있는 구간이 불규칙하므로 임의로 찾기 어렵다.

2   3   5   7   11  13  17  ......
소수인지 아닌지를 구분하는것은 의외로 아주 어렵다.

예를들면 3의 배수는 1,3,6,9,12,15,18,21...... 처럼 3 간격으로 나열되면 비교적 간다하다.
하지만 소수에는 규칙성이 없기 떄문에 간격이 불규칙하고 랜덤하다. 즉 소수를 한번에 열거하기는 어렵다.
하나하나 그 수보다 작은 숫자로 나누어 보고 나눌수 있으면 소수가 아닌것으로 판단할 수 있다.
이 방법은 비효율적이고,수의 범위가 커지면 어마어마하게 많은 시간이 소요된다.
고대 그리스의 에라토스테네스는 위와같은 방법을 개선하여 소수를 효율적으로 발견하는 방법을 고안했다.

에라토스테네스의 체는 '그 수의 제곱근보다 작은 소수의 배수를 없애면 남은 수가 소수다'
라는 생각을 바탕으로 소수를 찾는 방법을 말한다.
예를들면 100 이하의 소수를 모두 찾고싶으면 가장먼저 100의 제곱근 이하의 소수를 선택한다.
100의 제곱근은 10이므로 10 이하에서의 모든 소수는 2,3,5,7 네개이다.
2를 제외한 2의 배수를 제거한다.
3을 제외한 3의 베수를 제거한다.
5,7도 마찬가지로 같은방법으로 제거한다.

에라토스 테네스의 체 알고리즘
1.어떤 수 이하의 모든 정수 데이터를 준비
2.어떤 수의 제곱근 보다 작은 소수의 배수를 제거한다.
3. 마지막까지 남은 수를 출력한다.

#유클리드 알고리즘

최대 공양수를 구하는 알고리즘
최대 공약수는 공통의 약수중에서 가장 큰 수를 말한다.
반복구조를 이용하여 해결한다는 점에서 프로그래머가 알고있어야 할 대표적인 알고리즘이다.

약수
3의약수 1,3
4의 약수 1,2,4
5의 약수 1,5
6의 약수 1,2,3,6
8의 약수 1,2,4,8
12의 약수 1,2,3,4,6,12

공약수
4,6의 공약수 1,2
8,12의 공약수 1,2,4

최대공약수 : 공통된약수들중 제일 큰 숫자.
4,6의 공약수 2
8,12의 최대 공약수 4
6,12의 최대 공약수 6

유클리드 알고리즘이란? 두 수의 나눗셈을 반복하여 최대 공약수를 구한다.
12와 6의 최대공약수
12 % 6 = 0 #나머지가 없이 딱 나누어 떨어지는데 사용된 수가 최대 공약수
221 % 143 = 78
143 % 78 = 65
        % 65 = 13
            %13 = 0     #0이 나올때의 나누어준 수 13이 바로 최대공약수

# 나머지를 구하는 나눗셈의 산수 연산자
딱 나누어 떨어지지 않을떄에 나눗셈을 반복하는 처리를 반복구조로 표현한다.
반복구조에는 선판정형과 후판정형이 있다.
선 판정형 구조는 반복처리에 들어가기전에 조건식으로 판정을 실시한다.
후 판정형 구조는 반복 처리후에 조건식으로 판정을 실시한다. do ~ while 자바


#빅오 표기법
알고리즘이 얼마나 빠른지를 표시하는 특별한 방법

탐색
                   단순탐색            이진탐색
100개              100밀리초            7밀리 초
100000개            10초              14밀리 초
1000000000개         11일            32밀리 초

원소의 개수가 증가해도 이진탐색 시간은 얼마 늘어나지않는다.
하지만 단순탐색의 시간은 어마어마하게 증가된다.
원소의 갯수가 커질수록 이진탐색은 훨신 빨라지게된다.

빅오 표기법은 알고리즘이 얼마나 빠른지만 말해준다.

단순 탐색은 원소를 하나하나 확인하기 때문에 n번 연산을 해야한다.
빅오 표기법으로는 O(n) 이다. 빅오 표기법은 속도를 시간단위로 세지 않는다.
빅오 표기법은 연산 획수를 비교하기 위한 개념이다.
단순 탐색의 실행시간은 O(n) 로 나타낸다.

O(log n) 이진탐색
O(n) 선형 시간, 단순탐색
O(n * log n)
O(n^2) 선택 정렬,느린 정렬 알고리즘
O(n!) 외판원문제, 정말 느린 알고리즘
알고리즘의 속도는 시간으로 측정하지 않는다.
알고리즘의 시간은 어떻게 증가하는가로 측정한다.
알고리즘의 시간은 빅오표기법으로 나타낸다. 



"""